InnoDB目前为止一共有4种不同类型的行格式，分别为

   - COMPACT
   - REDUNDANT
   - DYNAMMIC
   - COMPRESSED

# 1.COMPACT
COMPACT格式
![](https://cdn.nlark.com/yuque/0/2021/jpeg/2860117/1637064598822-36428d0d-1498-49e0-95ca-0654776c3704.jpeg)
## 1.1变长字段长度列表
MYSQL支持可变长数据，如VARCHAR(),VARBINARY(),各BLOB类型等，因此需要存储这些可变长字段的具体长度，这就是变长字段列表所实现的功能。但如果某变长字段的值为NULL，那么变长字段长度列表会选择不保存该字段的长度，而非将其记录为0，值为NULL的变长字段会交由NULL值列表进行处理。
在变长字段列表中，所有数据都是逆序存放的。
示例如下：
记录1

| 列名 | 内容 | 内容长度（十六进制） |
| --- | --- | --- |
| c1 | 'a' | 0x01 |
| c2 | 'bb' | 0x02 |
| c3 | 'ccc' | 0x03 |

记录2

| 列名 | 内容 | 内容长度（十六进制） |
| --- | --- | --- |
| c1 | 'a' | 0x01 |
| c2 | NULL | 0x00 |
| c3 | 'ccc' | 0x03 |

![](https://cdn.nlark.com/yuque/0/2021/jpeg/2860117/1637059951932-de2217a1-4cb6-4e93-a1e0-e5bc0181df0e.jpeg)
注：实际上各字节之间没有空格，上图的空格仅为便于观察。

变长字段长度列表的项长度规则：
假设某个字符集最多需要W字节来表示一个字符，比如utf8的长度为1~3，那么Wutf8=3。
对于变长字段VARCHAR(M)而言，最多存储M个字符，那么该字段最多占用W×M个字节
假设变长字段的实际长度为L
如果W×M≦255，那么使用1字节来表示该变长字段
如果W×M>255，在L≦127时，使用1字节；在L>127时，使用2字节
注：InnoDB读取记录的变长字段时会先查询表结构，从而得知该字段的W×M值，从而确定1字节是否足够描述该字段的长度。此外，该字节的第一位为标志位，为0时表示该字节是一个单独的字段长度（W×M>255但L<=127），即相应的字段只需要用1个字节来描述其长度。为1时表示半个字段长度。

## 1.2NULL值列表
在一条记录中，某些列的值可以为NULL，如果将NULL值记录于数据段就会有点浪费，于COMPACT结构就会把NULL的列交由NULL值列表统一管理。
如果表中没有允许存储NULL的列，那么NULL值列表也就不存在。
在NULL值列表中，每个允许存储NULL的列对应一个二进制位，为1时表示该列为NULL。MYSQL还规定NULL列表长度单位为字节，如果可存储NULL的列数不是8的整数倍，那么就在高位补0。与变长字段长度列表类似，NULL值列表的二进制位也是逆序排列的。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/2860117/1637061305981-fd0f8411-39ab-46a2-bec5-650bc8658ce0.jpeg)

![](https://cdn.nlark.com/yuque/0/2021/jpeg/2860117/1637061512771-574d085b-7f31-4fca-9327-390a309f6003.jpeg)
## 1.3记录头信息
![](https://cdn.nlark.com/yuque/0/2021/jpeg/2860117/1637062291262-846b439c-8b8b-414e-b5e7-7e888b93de9d.jpeg)
详细作用

| 名称 | 大小（bit） | 描述 |
| --- | --- | --- |
| 预留位1&2 | 各占1位，共2位 | 暂无使用 |
| delete_flag | 1 | 标记该记录是否被逻辑删除，1为删除 |
| min_rec_flag | 1 | B+树每层非叶节点中最小的目录项记录都会添加该标记 |
| n_owned | 4 | 一个页面的记录会被分为若干个分组，每组的第一个记录的n_owned记录该小组的成员数量 |
| heap_no | 13 | 表示当前记录在页面堆中的相对位置 |
| record_type | 3 | 表示当前记录的类型，0为普通标记，1为非叶节点的目录项，2表示Infimum记录，3表示Supremum记录 |
| next_record | 16 | 记录下一节点的相对位置 |



## 1.4隐藏列&CHAR(M)列的存储格式
MYSQL会给每个表添加以下隐藏列

| 列名 | 是否必须 | 字段长度(Byte) | 描述 |
| --- | --- | --- | --- |
| DB_ROW_ID | 否 | 6 | 行ID，作为唯一标识符 |
| DB_TRX_ID | 是 | 6 | 事务ID |
| DB_ROLL_POINTED | 是 | 7 | 回滚指针 |

	InnoDB会优先选择使用用户自定义的主键，如果没有，就会选择一个不允许为NULL的UNIQUE键作为主键，两个都没有时才会添加DB_ROW_ID键，作为该表的唯一标识符。
**CHAR(M)列的存储格式**
由于变长编码字符集的存在，比如GBK表示一个字符要1~2字节，utf8需要1~3字节等，使得CHAR(M)的具体长度不确定。因此即使即使CAHR(M)列的字符数量确定，但该列依旧交由变长字段长度列表管理。而且与VARCHAR()不同的是，CAHR(M)列要求至少占用M个字节，这种设计是为了便于更新时无需重新分配空间，从而造成碎片。
示例：假如存在使用utf8字符集、类型为CHAR(10)的列，那么该列长度区间为[10，30]B，即使只存储一个空串，也会占用10个字节。

# 2.REDUNDANT
REDUNDANT格式是MySQL5.0以前所使用的行格式。
![](https://cdn.nlark.com/yuque/0/2021/jpeg/2860117/1637069318517-f7011d01-1f1c-4b6b-b72c-50ec68c342fe.jpeg)

**2.1字段长度偏移列表**
REDUNDANT种会将所有列（包含隐藏列）的长度信息都逆序存储在字段长度偏移列表中，由于是记录的是偏移量，所以字段的长度需要两个相邻偏移量相减才可以求得。

**2.2记录头信息**

| 名称 | 大小（bit） | 描述 |
| --- | --- | --- |
| 预留位1&2 | 各占1位，共2位 | 暂无使用 |
| delete_flag | 1 | 标记该记录是否被逻辑删除，1为删除 |
| min_rec_flag | 1 | B+树每层非叶节点中最小的目录项记录都会添加该标记 |
| n_owned | 4 | 一个页面的记录会被分为若干个分组，每组的第一个记录的n_owned记录该小组的成员数量 |
| heap_no | 13 | 表示当前记录在页面堆中的相对位置 |
| n_field | 10 | 表示记录的列数量 |
| 1byte_offs_flag | 1 | 标记字段长度偏移列表中，每个列对应的偏移量使用1字节还是2字节表示 |
| next_record | 16 | 记录下一节点的相对位置 |

1byte_offs_flag
=1：当记录的真实数据长度不大于127时（因为第一个bit用于处理NULL），使用1字节
=0：当记录的真实数据长度大于127，但不大于32767（0x7FFF）时，使用2字节
**2.3NULL值的处理**
如上所示，偏移量值的第一个比特位用于判断列的值是否位NULL，NULL比特位=1时表示该列的值为NULL。

**2.4CHAR(M)的存储**
REDUNDANT对于CHAR(M)的存储十分简单粗暴，直接用列所用字符集的单个字符最大长度*M的空间保存数值。比如CHAR（10）类型的列使用UTF8字符集，那么它就会用30个字节来保存它的值。优点是更新速度快，直接在原位置更新，无需重新分配。缺点便是可能会浪费一定的空间。

# 3.补充
## 3.1溢出列(off-page列)
假设某一列的真实数据长度大于页可容纳的范围，那么在真实数据的最后20个字节会保存指向保存剩余数据的页面。
MYSQL一个页中至少要保存两行记录，同时页的结构信息总计需要132字节，每个记录的额外信息为27字节（只有一个列），那么就需要满足公式132+2×（27+n）<16384 (16KB)
假设只有一个列的表中，有条记录保存了长度为65332的字符串（内容为'aaaa...aaaa'）那么其保存情况如下所示
![](https://cdn.nlark.com/yuque/0/2021/jpeg/2860117/1637076589449-1b472c5f-a5eb-4f1e-bc4f-c7d471c16143.jpeg)

## 3.2DYNAMIC&COMPRESSED
DYNAMIC格式（MySQL 5.7的默认行格式）与COMPACT类似，但在溢出列的处理上有分歧，DYNAMIC格式中，会将溢出列的所有数据都保存于溢出页中，记录中的溢出列位置只会保存相应的指针。
COMPRESSED格式不同于DYNAMIC的一点是，前者会使用压缩算法对页面进行压缩处理，从而节省空间。
